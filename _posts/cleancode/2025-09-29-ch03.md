---
title: "[클린 코드] 함수"
date: 2025-09-29 10:00:00 +0900
categories: [Clean Code]
tags: [클린코드, 함수]
description: "클린 코드 3장을 요약합니다."
---

## 서론

함수는 코드의 기본 단위다.
**짧고 명확한 함수**는 의도가 바로 보이고, 협업·유지보수가 쉬워진다. 『클린 코드』 3장은 핵심을 **“작게, 한 가지만, 일관된 추상화”**로 요약한다.

---

## 작게 만들어라!

함수는 **짧으면 짧을수록** 이해·테스트가 쉽다.

```java
// 나쁨: 여러 일을 한 함수에 몰아넣음
public void processOrder(Order o) { /* 결제 + 재고 + 배송 */ }

// 좋음: 짧게 쪼갬
public void processOrder(Order o) {
  processPayment(o);
  updateInventory(o);
  prepareShipping(o);
}
```

* **더 짧게** 쪼개고, 흐름이 한눈에 보이게 만든다.

---

## 한 가지만 해라!

함수는 **한 가지 일**만 하라.

```java
// 나쁨
public void saveUser(User u){ validate(u); repo.save(u); sendEmail(u); }

// 좋음
public void saveUser(User u){ validate(u); repo.save(u); }
public void notifyUser(User u){ sendEmail(u); }
```

* 이름과 동작이 **1:1**로 대응돼야 한다.

---

## 블록과 들여쓰기

블록(`if/else/while`)은 **짧게**. 길어지면 **함수 추출**.

```java
// 나쁨
if (user.isActive()) { println("active"); sendEmail(u); updateLastLogin(u); }

// 좋음
if (user.isActive()) handleActiveUser(u);
```

* 목표: **얕은 들여쓰기**, **평평한 코드**.

---

## 함수당 추상화 수준은 하나로! (+ 내려가기 규칙)

한 함수 안에 **고수준과 저수준**을 섞지 말라.
위의 함수가 아래 함수를 호출할 때 **한 단계씩만** 추상화 수준을 낮춘다.

```java
public void generateReport() {            // 고수준
  Report r = createMonthlyReport();       // 중간
  saveReportToFile(r);                    // 중간
}
```

* 위→아래로 읽을수록 **세부 구현**만 드러나게 설계.

---

## 스위치 문은 피해라

분기 추가 때마다 수정이 퍼지고 **중복**이 생긴다. 가능하면 **다형성**으로 대체.

```java
abstract class Employee { abstract double pay(); }
class Engineer extends Employee { double pay(){...} }
// 스위치는 생성 시 한 번만.
```

---

## 서술적인 이름을 사용하라!

짧지만 모호한 이름보다 **길어도 명확한 이름**이 낫다.

* 나쁨: `handle()`, `doIt()`
* 좋음: `sendEmailToCustomer()`, `validatePaymentInfo()`

---

## 함수 인수는 적게

이상적: **0~2개**. 불가피하면 **연관 인수는 객체로 묶기**.

```java
// 나쁨
drawText(String text, int x, int y);

// 좋음
drawText(String text, Point pos);
```

* **플래그 인수(Boolean)** 는 동작이 둘임을 뜻하니 분리하라.
* **동사+키워드**로 호출이 문장처럼 읽히게: `assertEquals(expected, actual)`.

---

## 부수 효과를 일으키지 마라

함수는 **약속한 일만** 수행.

```java
// 나쁨: 조회가 세션 초기화까지 함
boolean checkPassword(u,p){ ... Session.init(); return true; }

// 좋음: 역할 분리
boolean checkPassword(u,p){ ... }
void initializeSession(User u){ ... }
```

---

## 명령과 조회를 분리하라

* **명령**: 상태 변경, 값을 **반환하지 않음**
* **조회**: 값 반환, 상태 **변경 없음**

```java
void setPassword(String p){...}
boolean checkPassword(String p){...}
```

---

## 오류 코드보다 예외를 사용하라

오류 코드는 호출부 조건문을 **증식**시킨다. 예외로 **핵심 로직과 에러 처리**를 분리하라.

```java
void withdraw(int amt){
  if (balance < amt) throw new InsufficientBalanceException();
  balance -= amt;
}
```

* `try-catch`는 **별도 함수**로 빼서 본문을 깨끗하게.

---

## 반복하지 마라 (DRY)

중복은 수정 비용·버그를 키운다. **함수 추출/공유**, **다형성**으로 제거.

```java
private void printInvoiceInfo(Invoice i){...}
```

---

## 구조적 프로그래밍

가능하면 **하나의 입구·하나의 출구**.
짧은 함수는 조기 `return` 허용, 길어지면 **출구 하나**로 단순화.

---

## (추가) 예외 처리도 “한 가지 일”

예외 처리는 **핵심 로직과 분리**하라. 예외 흐름이 본문을 덮지 않게 한다.

```java
public void placeOrder(Order o){
  tryPlaceOrder(o);        // 본문은 짧게 유지
}

private void tryPlaceOrder(Order o){
  try { process(o); }
  catch (PaymentException e){ notifyFailure(o, e); }
}
```

---

## 주석보다 코드로 의도를 드러내라

주석 대신 **이름과 분리**로 의도를 표현하라.

```java
// before
// 할인율이 10% 이상이면 VIP
if (rate >= 0.1) { ... }

// after
if (isVipRate(rate)) { ... }
private boolean isVipRate(double rate){ return rate >= 0.1; }
```


---

## 앞으로 함수를 작성할 때 생각해야 할 것들

* 길이는 충분히 **짧은가?**
* **한 가지 일**만 하는가?
* 한 함수에 **추상화 수준 하나**만 담았는가? (내려가기 규칙)
* **플래그 인수**는 없는가? 인수는 **0~2개**인가?
* **부수 효과**는 없는가? 명령/조회가 **분리**되어 있는가?
* **예외**로 오류를 다루고 `try-catch`는 **분리**했는가?
* **중복**은 제거했는가? 블록은 **한 줄**인가?
* 이름이 **서술적**이고 호출이 **문장처럼** 읽히는가?
