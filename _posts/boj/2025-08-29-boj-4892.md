---
title: "[BOJ] 4892번. 숫자 맞추기 게임 "
date: 2025-08-29 12:00:00 +0900
categories: [boj]              
tags: [boj, 구현, 수학]
# math: true   # (MathJax/KaTeX 쓰면 주석 해제)
excerpt: "모든 중간 계산 없이 n1의 짝/홀, n4를 한 번에 구한다: n1은 n0와 동일한 짝/홀, n4 = ⌊n0/2⌋"
---
[백준 문제 링크](https://www.acmicpc.net/problem/4892)

---

### 숫자 맞추기 게임

* 어떤 수 `n0`를 머릿속에 생각한다.
* 다음 규칙에 따라 계산을 진행한다:

  1. `n1 = 3 * n0`

     * `n1`이 짝수인지 홀수인지 확인한다.
  2. `n1`이 짝수라면 `n2 = n1 / 2`,
     `n1`이 홀수라면 `n2 = (n1 + 1) / 2`
  3. `n3 = 3 * n2`
  4. `n4 = n3 / 9` (정수 나눗셈, 몫만 취함)
* 친구는 `n1`의 홀짝 여부와 `n4`의 값을 알려준다.
* 이를 통해 처음 생각한 수 `n0`를 맞출 수 있다.

**문제에서 요구하는 것:**

* 입력으로 `n0`가 주어졌을 때
* `n1`의 홀짝 여부와 `n4`의 값을 출력한다.

---

### 입력과 반복 구조

나는 비용을 많이 잡아먹는 `Scanner` 사용을 지양하고 있기에, `BufferedReader`를 사용해 문제를 푸는 것을 습관화하고 있다.
먼저 사용할 도구를 세팅한다.

```java
/** 필드값 선언 **/
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
```

입력은 여러 개의 테스트 케이스로 이루어져 있고, **0이 나오기 전까지** 계속해서 반복된다.
반복을 설계할 때는 두 가지 선택지가 있는데, `while (true)` + `break` 보다는 종료 조건을 루프 조건에 직접 표현하는 방식을 선호한다.

```java
/** 반복문 **/
int n;
int caseNo = 0;
while ((n = Integer.parseInt(br.readLine())) != 0) {
    // 각 테스트 케이스 처리
}
```

---

### 내부 연산 흐름

반복문 내부에서는 다음 순서를 지킨다.

1. `n1`을 만든다 → 여기서 **짝/홀**을 판정한다.
2. 짝/홀에 따라 `n2`를 결정한다.
3. `n3`, `n4`를 순차로 구한다.
4. 출력 형식에 맞춰 케이스 번호, 짝/홀, `n4`를 출력한다.

> 포인트: 홀수일 때 1을 더해 2로 나누는 이유는, 항상 **정수 연산**이 되도록 만들기 위함이다.
> 즉, “짝수면 바로 2로 나누고, 홀수면 하나 올려서 2로 나누기”라는 규칙이 핵심.


```java
caseNo++;

int n1 = /* 3 * n */;
String parity; // "even" 또는 "odd"
int n2;

/** 짝/홀 분기 **/
if (/* n1이 짝수 */) {
    parity = "even";
    n2 = /* n1 / 2 */;
} else {
    parity = "odd";
    n2 = /* (n1 + 1) / 2 */;
}

/** 후속 계산 **/
int n3 = /* 3 * n2 */;
int n4 = /* n3 / 9 */; // 정수 나눗셈

/** 출력 **/
System.out.println(caseNo + ". " + parity + " " + n4);
```

---
