---
title: "[BOJ] 찍기 (2966)"
date: 2025-09-29 16:00:00 +0900
categories: [BOJ]
tags: [BOJ, 구현, 시뮬레이션, 문자열]
math: true
excerpt: "세 사람이 반복 패턴으로 답안을 찍을 때, 정답과 비교해 최다 득점자를 구하는 문제."
---

![찍기](https://github.com/user-attachments/assets/5e1dd6a9-0cf0-4878-9710-e8d71eb3bc27)

## [백준 2966 — 찍기](https://www.acmicpc.net/problem/2966)

세 명이 고정 **반복 패턴**으로 찍는다. 정답 문자열이 주어지면, 누가 가장 많이 맞혔는지 출력한다. 동점이면 **Adrian → Bruno → Goran** 순서로 한 줄씩.

---

## 핵심 아이디어

* 패턴

  * Adrian: `A B C` (길이 3)
  * Bruno: `B A B C` (길이 4)
  * Goran: `C C A A B B` (길이 6)
* i번째 문제의 비교는 **나머지 인덱싱**으로 처리: 각자 `i mod L` 위치 문자와 정답을 대조해 카운트만 올린다.
* 최댓값을 구하고, 같은 점수인 사람만 **정해진 순서**대로 출력.

> 왜 나머지?
> 패턴 끝에서 다시 처음으로 돌아가는 **원형 접근**을 수식 한 번으로 표현하기 위해.

---

## 예시

정답 `BAACC`일 때
Adrian: `A B C A B ...`
Bruno:  `B A B C B ...`
Goran:  `C C A A B ...`
→ Bruno가 3개로 최다.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        br.readLine();
        String s = br.readLine().trim();

        char[] A = {'A','B','C'};
        char[] B = {'B','A','B','C'};
        char[] G = {'C','C','A','A','B','B'};
        int sa = 0, sb = 0, sg = 0;
        for (int i = 0; i < s.length(); i++) {
            char ans = s.charAt(i);
            if (ans == A[i % A.length]) sa++;
            if (ans == B[i % B.length]) sb++;
            if (ans == G[i % G.length]) sg++;
        }

        int max = Math.max(sa, Math.max(sb, sg));
        StringBuilder out = new StringBuilder();
        out.append(max).append('\n');
        if (sa == max) out.append("Adrian\n");
        if (sb == max) out.append("Bruno\n");
        if (sg == max) out.append("Goran\n");

        System.out.print(out.toString());
    }
}
```



