---
title: "[BOJ/Kattis] 11104번. Fridge of Your Dreams"
date: 2025-08-29 13:00:00 +0900
categories: [BOJ]
tags: [BOJ, 구현, 문자열, 진수변환]
math: true
excerpt: "24비트 이진수 문자열을 10진수로 변환하는 문제. 직접 구현, 비트 시프트, 내장 메서드 세 가지 풀이가 가능하다."
---

[문제 출처: IDI Open 2007 G — *Fridge of Your Dreams*](https://www.acmicpc.net/problem/11104)

---

## 문제 요약

- 센서가 내보내는 **24비트 이진수 문자열**을 읽어 10진수로 변환하는 문제.
- 입력:
  - 첫 줄: 테스트 케이스 개수 `n (≤ 1000)`
  - 이후: `n`개의 24비트 이진수 문자열
- 출력: 각 문자열을 **10진수 정수**로 변환해 출력 (선행 0 제거)

---

## 예시

### 입력
```

5
000000000000000000000001
000000000001010101010101
000000000000000000001010
101011001010101100101101
111111111111111111111111

```

### 출력
```

1
5461
10
11316013
16777215

````

---

## 풀이 아이디어

이 문제는 사실 **내장 메서드 한 줄**로 해결 가능하다:

```java
int decimal = Integer.parseInt(binary, 2);
````

하지만 직접 구현을 해보면 **이진수 → 십진수 변환 원리**를 다시 확인할 수 있다.

* **자리값 방식**
  오른쪽(최하위 비트)부터 시작해 `'1'`인 경우 해당 자리값을 더한다.
  자리값은 매번 2배(`power *= 2`).
* **비트 시프트 방식**
  `decimal = (decimal << 1) + (bit)` 식으로 왼쪽으로 밀며 누적.
  곱셈·거듭제곱 변수 없이 간결하다.
* **범위 안전성**
  24비트 최대값 = `16,777,215` → `int` 범위(약 21억) 안에서 안전.

---

## 코드 (자리값 누적 방식)

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine().trim());
        StringBuilder out = new StringBuilder();

        for (int t = 0; t < n; t++) {
            String binary = br.readLine().trim();

            int decimal = 0;
            int power = 1; // 2^0

            for (int j = binary.length() - 1; j >= 0; j--) {
                if (binary.charAt(j) == '1') {
                    decimal += power;
                }
                power *= 2;
            }
            out.append(decimal).append('\n');
        }

        System.out.print(out);
    }
}
```

---

## 코드 (비트 시프트 방식)

```java
int decimal = 0;
for (int i = 0; i < binary.length(); i++) {
    decimal = (decimal << 1) + (binary.charAt(i) - '0');
}
```

* `(decimal << 1)` = `decimal * 2`와 동일.
* 자리값 변수를 따로 둘 필요가 없어 더 간결하다.

---

## 코드 (내장 메서드)

```java
int decimal = Integer.parseInt(binary, 2);
```

* 가장 짧고 직관적인 방법.
* 더 큰 비트 문자열일 경우 `Long.parseLong(binary, 2)` 또는 `new BigInteger(binary, 2)` 사용.

---

## 복잡도 분석

* 각 문자열 길이 = 24 → 변환 O(24) = O(1)
* 전체 `n ≤ 1000` → 매우 빠르다
* 메모리 사용: O(1)

---

## 시행착오

* **`trim()` 필수**: 입력 문자열에 공백/개행이 섞이면 파싱 실패 또는 오답 발생.

---

## 회고

* 이 문제는 **구현 난이도는 낮지만**, 여러 방식으로 풀 수 있는 좋은 예제다.
* 직접 자리값을 계산해 보는 건 원리를 이해하는 데 도움이 된다.
* 실전 대회에서는 `Integer.parseInt(binary, 2)` 같은 내장 메서드를 쓰는 게 가장 안전하고 빠르다.
