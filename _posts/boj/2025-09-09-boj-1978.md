---
title: "[BOJ] 소수 찾기"
date: 2025-09-09 14:30:00 +0900
categories: [BOJ]
tags: [BOJ, 수학]
math: true
excerpt: "주어진 수들 중 소수의 개수를 구하는 문제 풀이 정리"
---

![소수 판별](https://github.com/user-attachments/assets/0d719937-d512-4f22-b364-40bc22e86d42)

## [백준 xxxx번 — 소수 찾기](https://www.acmicpc.net/problem/xxxx)

총 \(N\)개의 수가 주어졌을 때, 이들 중에서 소수의 개수를 세는 문제입니다.  
단순히 하나씩 나눠보는 방법도 가능하지만, \(N\)의 범위가 커질 경우 **에라토스테네스의 체**를 활용하면 효율적으로 풀 수 있습니다.  

조건:
* 소수는 1과 자기 자신만으로 나누어지는 수입니다.
* \(1\)은 소수가 아닙니다.

---

## 풀이 아이디어

    * **소수 판별**  
    * 먼저 $2 \sim MAX$ 범위의 소수를 *에라토스테네스의 체*로 전처리합니다.
    * 합성수의 배수를 미리 제거해두면, 각 수를 빠르게 소수인지 판별할 수 있습니다.

    * **배열 순회**  
    * 입력받은 배열을 순회하면서, $prime[x] = \text{true}$ 인 경우 카운트를 증가시킵니다.



---

## 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int count = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());

        int[] arr = new int[count];

        final int MAX = 1000;
        boolean[] prime = new boolean[MAX + 1];
        Arrays.fill(prime, true);
        prime[0] = false;
        prime[1] = false;

        // 에라토스테네스의 체
        for (int i = 2; i * i <= MAX; i++) {
            if (prime[i]) {
                for (int j = i * i; j <= MAX; j += i) {
                    prime[j] = false;
                }
            }
        }

        int result = 0;
        for (int i = 0; i < count; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
            if (prime[arr[i]]) result++;
        }

        System.out.println(result);
    }
}
````

---

## 에라토스테네스의 체 원리

1. $2$부터 시작해서 남아있는 수를 소수로 확정합니다.
2. 그 수의 배수를 모두 제거합니다.
3. 다음 남아있는 수로 넘어가 반복합니다.
4. $\sqrt{MAX}$까지 수행하면 모든 소수가 걸러집니다.

즉, 반복문

$$
\texttt{for (int j = i * i; j <= MAX; j += i)}
$$

는 소수 $i$의 배수들을 차례대로 지우는 역할을 합니다.

---

## 단계별 예시 ($MAX = 30$)

| 단계      | i 값                 | 동작                                     | 남은 소수 후보 (prime = true) |
| ------- | ------------------- | -------------------------------------- | ----------------------- |
| 초기      | -                   | 모든 수 소수 후보                             | 2, 3, 4, 5, 6, 7, …, 30 |
| i=2     | 2는 소수 → 2의 배수 제거    | 2, 3, 5, 7, 9, 11, 13, …, 29           |                         |
| i=3     | 3은 소수 → 3의 배수 제거    | 2, 3, 5, 7, 11, 13, 17, 19, 23, 25, 29 |                         |
| i=4     | 이미 false(지워짐) → 건너뜀 | 변화 없음                                  |                         |
| i=5     | 5는 소수 → 5의 배수 제거    | 2, 3, 5, 7, 11, 13, 17, 19, 23, 29     |                         |
| i > √30 | 종료                  | 최종 소수 확정                               |                         |

최종적으로 남는 수들은

$$
\{2, 3, 5, 7, 11, 13, 17, 19, 23, 29\}
$$

입니다.

---

## 풀이 과정 정리

1. **소수 전처리**

   * `boolean[] prime` 배열을 만들어 $prime[x] = \text{true}$ → 소수 후보로 둡니다.
   * $0$과 $1$은 소수가 아니므로 false 처리합니다.
   * $2 \leq i \leq \sqrt{MAX}$ 범위에서, 소수의 배수를 전부 false로 바꿉니다.

2. **배열 검사**

   * 입력받은 배열에서 각 수가 `prime[]`에서 true인지 확인합니다.
   * 소수라면 카운트를 증가시킵니다.

3. **출력**

   * 소수의 개수를 출력합니다.

---

## 풀이 후기

이 문제의 핵심은 **에라토스테네스의 체의 동작 원리**를 이해하고 코드로 구현하는 것입니다.
특히 $i^2$부터 배수를 지우기 시작하는 부분은 **중복 계산을 피하면서 효율을 높이는 포인트**입니다.

단순 나눗셈으로 소수를 판별할 수도 있지만, 여러 번 판별이 필요한 상황에서는 **체를 통한 전처리**가 훨씬 빠르다는 점을 다시 확인할 수 있었습니다.
