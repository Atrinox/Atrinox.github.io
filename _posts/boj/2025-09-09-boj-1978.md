---
title: "[BOJ] 소수 찾기 (1978)"
date: 2025-09-09 14:30:00 +0900
categories: [BOJ]
tags: [BOJ, 수학]
math: true
excerpt: "주어진 수들 중 소수의 개수를 구하는 문제 풀이 정리"
---

![소수 판별](https://github.com/user-attachments/assets/0d719937-d512-4f22-b364-40bc22e86d42)

## [백준 1978번 — 소수 찾기](https://www.acmicpc.net/problem/1978)

총 $N$개의 수가 주어졌을 때, 이들 중 소수의 개수를 세는 문제.
단순히 하나씩 나눠보는 방법도 가능하지만, 범위가 클수록 **에라토스테네스의 체**로 전처리하면 효율적이다.

조건:

* 소수는 1과 자기 자신만으로 나누어진다.
* $1$은 소수가 아니다.

---

## 풀이 아이디어

* **전처리로 소수 집합 만들기**
  $2 \sim \text{MAX}$ 범위의 소수를 *에라토스테네스의 체*로 구해 둔다.

* **합성수 제거 원리**
  어떤 소수 $i$가 확정되면, 그 배수들을 지워나간다.
  중복 제거를 위해 $i^2$부터 시작해도 충분하다.

* **카운팅**
  입력 배열을 순회하며 $\texttt{prime[x]}$가 참이면 카운트를 증가시킨다.

---

## 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int count = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());

        int[] arr = new int[count];

        final int MAX = 1000;
        boolean[] prime = new boolean[MAX + 1];
        Arrays.fill(prime, true);
        prime[0] = false;
        prime[1] = false;

        // 에라토스테네스의 체
        for (int i = 2; i * i <= MAX; i++) {
            if (prime[i]) {
                for (int j = i * i; j <= MAX; j += i) {
                    prime[j] = false;
                }
            }
        }

        int result = 0;
        for (int i = 0; i < count; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
            if (prime[arr[i]]) result++;
        }

        System.out.println(result);
    }
}
```

---

## 에라토스테네스의 체 원리

1. $2$부터 시작해서 남아 있는 수를 소수로 확정한다.
2. 그 수의 배수를 모두 제거한다.
3. 다음 남아 있는 수로 넘어간다.
4. $\sqrt{\text{MAX}}$까지만 반복해도 모든 합성수가 걸러진다.

즉, 아래 반복문은 소수 $i$의 배수들을 지우는 역할을 한다.

$$
\texttt{for (int j = i * i; j \le \text{MAX}; j += i)}
$$

---

## 단계별 예시 ($\text{MAX} = 30$)

| 단계              | i 값                 | 동작                                     | 남은 소수 후보 (prime = true) |
| --------------- | ------------------- | -------------------------------------- | ----------------------- |
| 초기              | -                   | 모든 수 소수 후보                             | 2, 3, 4, 5, 6, 7, …, 30 |
| i=2             | 2는 소수 → 2의 배수 제거    | 2, 3, 5, 7, 9, 11, 13, …, 29           |                         |
| i=3             | 3은 소수 → 3의 배수 제거    | 2, 3, 5, 7, 11, 13, 17, 19, 23, 25, 29 |                         |
| i=4             | 이미 false(지워짐) → 건너뜀 | 변화 없음                                  |                         |
| i=5             | 5는 소수 → 5의 배수 제거    | 2, 3, 5, 7, 11, 13, 17, 19, 23, 29     |                         |
| i > $\sqrt{30}$ | 종료                  | 최종 소수 확정                               |                         |

최종적으로 남는 수:

$$
\{\,2,\,3,\,5,\,7,\,11,\,13,\,17,\,19,\,23,\,29\,\}
$$

---

## 풀이 후기

핵심은 **배수 제거를 $i^2$부터 시작**해 중복 계산을 줄이는 것.
여러 값을 반복 판별해야 할 때, 전처리된 소수 테이블을 활용하면 훨씬 빠르게 답을 구할 수 있었다.
