---
title: "[BOJ] 분해합 (2231)"
date: 2025-09-09 14:30:00 +0900
categories: [BOJ]
tags: [BOJ, 구현, 수학, 브루트포스]
math: true
excerpt: "자연수 N의 가장 작은 생성자를 찾는 문제. 자릿수 합의 최대치를 이용해 탐색 구간을 크게 줄이는 아이디어."
---

![분해합](https://github.com/user-attachments/assets/787949dc-9907-4df2-9b27-dd9b6dbbd7d4)

## [백준 2231 — 분해합](https://www.acmicpc.net/problem/2231)

어떤 자연수 $M$의 **분해합**은 $M$과 그 자릿수들의 합입니다.
자연수 $N$이 주어졌을 때, 분해합이 $N$이 되는 가장 작은 $M$ (생성자)을 구하는 문제입니다.
생성자가 없다면 0을 출력합니다.

---

## 풀이 아이디어

**핵심 관찰**

* 생성자는 $M + S(M) = N$을 만족합니다. 여기서 $S(M)$은 $M$의 자릿수 합입니다.
* $N$의 자릿수가 $k$라면, 자릿수 합의 최댓값은 $9k$입니다.
* 따라서 생성자 후보는 아래 구간만 보면 충분합니다.

$$
\text{start}=\max\!\bigl(1,\,N-9k\bigr), \quad \text{end}=N-1
$$

**절차**

1. $N$의 자릿수 $k$를 구한다.
2. 탐색 시작점 $\text{start}$를 $\max(1, N-9k)$로 둔다.
3. $\text{start} \le i \le N-1$를 작은 수부터 순회하며

   * $i$의 자릿수 합을 구해 $i + S(i) = N$인지 확인
   * 처음 성립하는 $i$를 즉시 출력(가장 작은 생성자 보장)
4. 끝까지 없으면 0 출력

---

## 수식으로 정리

* 자릿수 합 상한: $\displaystyle \max S(M) = 9k$
* 후보 구간: $\displaystyle M \in \left[\max(1, N-9k),\, N-1\right]$

---

## 예시

* $N=216$ (세 자리, $k=3$)
  $\text{start} = 216 - 27 = 189$.
  $189 \sim 215$ 중에서 처음 성립하는 값은 $198$ → $198 + (1+9+8) = 216$.

* $N=1000$ (네 자리, $k=4$)
  $\text{start} = 1000 - 36 = 964$.
  $964 \sim 999$ 중에서 $977$이 성립 → $977 + (9+7+7) = 1000$.

---

## 복잡도

* 후보 개수는 최대 $9k$개 수준이고, 각 후보에서 자릿수 합 계산에 $O(k)$가 듭니다.
* 전체 시간 복잡도는 $O(9k^2)$로, $k$가 작아 매우 빠르게 동작합니다.

---

## 구현 체크리스트

* [ ] $k$ 계산: 10으로 나누며 자릿수 세기(또는 안전한 방식)
* [ ] 하한: $\max(1, N-9k)$
* [ ] 상한: $N-1$ **포함**
* [ ] 작은 후보부터 검사 → **처음** 성립하는 순간 출력
* [ ] 끝까지 없으면 0

---

## 코드

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    private static int digitSum(int x) {
        int s = 0;
        while (x > 0) {
            s += x % 10;
            x /= 10;
        }
        return s;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int len = 0, tmp = n;
        while (tmp > 0) {
            tmp /= 10;
            len++;
        }

        int start = Math.max(1, n - len * 9);

        for (int i = start; i < n; i++) {
            if (i + digitSum(i) == n) {
                System.out.println(i);
                return;
            }
        }
        System.out.println(0);
    }
}

```

---

## 테스트 케이스 (권장)

* 1 → 0
* 5 → 0
* 21 → 15
* 216 → 198
* 100 → 86
* 1000 → 977

---

## 정리

이 문제의 포인트는 **탐색 구간 축소**입니다.
자릿수 합의 최댓값이 $9k$라는 사실만 알면, 전체를 브루트포스하지 않고도
$\max(1, N-9k) \sim N-1$만 빠르게 확인해 **가장 작은 생성자**를 찾을 수 있습니다.
