---
title: "[BOJ] 추론 (1731)"
date: 2025-09-15 14:30:00 +0900
categories: [BOJ]
tags: [BOJ, 구현, 수학, 수열]
math: true
excerpt: "주어진 수열이 등차/등비인지 판별해 다음 항을 추론하는 문제. 첫 세 항으로 빠르게 분기하고, 교차곱 조건으로 등비를 안전하게 확인한다."
---

![추론](https://github.com/user-attachments/assets/3310b6d6-63e5-48fb-b262-ffc19f8996bd)

## [백준 1731 — 추론](https://www.acmicpc.net/problem/1731)

수열의 길이 $N$ ($3 \le N \le 50$)과 $N$개의 정수가 주어진다.
이 수열이 **등차수열**이거나 **등비수열**이라는 보장 하에, **다음 항**을 출력한다.

---

## 풀이 아이디어

* 판별은 **처음 세 항** $a_1,a_2,a_3$만으로 충분.
* **등차수열 판별**

  $$
  a_2-a_1 \stackrel{?}{=} a_3-a_2
  $$

  참이면 공차 $d=a_2-a_1$, 다음 항은 **마지막 항 + $d$**.
* **등비수열 판별(안전한 방식)**
  정수 나눗셈은 버림이 생겨 위험하므로, **교차곱**으로 확인:

  $$
  a_2^2 \stackrel{?}{=} a_1\cdot a_3
  $$

  참이면 공비 $r$이 일정. 다음 항은 **마지막 항 × $r$** 로 구한다.
  (공비는 $a_2/a_1$ 또는 $a_3/a_2$로 “딱 나누어떨어지는” 쪽을 사용.)
* **동시성 케이스**: 모든 항이 같은 경우(예: $5,5,5,\dots$)는 등차·등비가 모두 성립하지만 \*\*다음 항은 동일(=같은 값)\*\*이므로 한 번만 출력되도록 분기 순서를 정해준다.

---

## 예시

* 입력: `364 843 1322 1801`
  차이가 모두 **479** → 등차수열 → 다음 항 **2280**.
* 입력: `2 6 18`
  $a_2^2=36,\,a_1a_3=36$ → 등비수열(공비 3) → 다음 항 **54**.
* 입력: `0 0 0`
  둘 다 성립하지만 다음 항은 **0**으로 동일.

---

## 시행착오

* **비율을 나눗셈으로 비교**
  `a2/a1 == a3/a2`처럼 비교하면 정수 나눗셈의 **버림** 때문에 오판 가능 → **교차곱** $a_2^2 = a_1a_3$을 사용.
* **0이 섞인 등비 처리**
  $a_1=0$인 경우는 별도 점검이 필요. $0,0,0$은 OK지만, $0,0,\neq 0$은 **등비 아님**. 앞이 0이 아닌데 중간이 0이면 공비 0이므로 다음 항도 0이어야 일관됨.
* **곱셈 오버플로**
  $a_2^2$나 $a_1a_3$는 값 범위를 크게 키운다. 곱셈 비교는 더 넉넉한 수 범위를 가정해 계산한다.
* **분기 시점**
  $N=3$에서도 판별이 되도록 **세 번째 항을 읽는 순간**에 판별을 끝내 두는 편이 안전하다.
* **이중 출력 방지**
  등차·등비가 동시에 참일 수 있으므로 **한 번만 출력**되도록 `if … else if …` 식의 단일 분기를 유지.

---

## 코드

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        boolean a = false;
        boolean b = false;

        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = Integer.parseInt(br.readLine());

            if (i == 2) {
                if (arr[2] - arr[1] == arr[1] - arr[0]) {
                    a = true;
                }
                if ((long) arr[1] * arr[1] == (long) arr[0] * arr[2]) {
                    b = true;
                }
            }

            if (i == N - 1) {
                if (a) {
                    System.out.println(arr[i] + (arr[2] - arr[1]));
                } else if (b) {
                    System.out.println((long) arr[i] * arr[2] / arr[1]);
                }
            }
        }
    }
}


```

* 입력을 받으며 **세 번째 항까지** 도달하면 즉시 판별:

  * 등차 체크: $a_2-a_1 = a_3-a_2$ → 공차 $d=a_2-a_1$.
  * 아니면 등비 후보 체크: $a_2^2 = a_1a_3$ (곱셈은 넉넉한 범위로).
  * 0이 섞인 경우는 위 **시행착오** 절을 따라 예외를 먼저 걸러준다.
* 마지막 항까지 읽은 뒤,

  * 등차로 분기되었다면 **마지막 항 + $d$** 출력.
  * 그렇지 않고 등비라면 **마지막 항 × $r$** 출력.
    (공비 $r$은 앞둘/뒷둘의 “정확한 배수 관계”를 이용해 정수로 확정한다.)
* 등차·등비가 **모두 성립**하는 상수 수열은 앞 분기에 걸리는 쪽 하나만 수행.

---

## 정리

핵심은 **첫 세 항으로 빠르게 분기**하고, 등비 여부는 **교차곱**으로 **안전하게** 확인하는 것.
그 뒤에는 “**마지막 항에 한 번 더**”라는 일관된 규칙(등차는 $+d$, 등비는 $\times r$)만 적용하면 된다.
