---
title: "[BOJ] 오르막길 (2846)"
date: 2025-09-25 22:00:00 +0900
categories: [BOJ]
tags: [BOJ, 구현, 시뮬레이션]
math: true
excerpt: "연속된 증가 구간(오르막길) 중 가장 큰 높이 차를 구하는 문제. 한 칸씩 비교하며 오르막의 시작점을 추적하는 아이디어."
---
![오르막길](https://github.com/user-attachments/assets/06f1c59f-ba2f-47a0-95fe-ecebf90fcad3)

## [백준 2846 — 오르막길](https://www.acmicpc.net/problem/2846)

자전거 길 높이가 주어졌을 때, 연속된 구간 중 **오르막길**의 크기가 가장 큰 값을 구한다.  
오르막길은 길이가 2 이상이며, 오름차순으로 이어지는 구간. 크기는 `(마지막 높이 − 첫 높이)`.

---

## 풀이 아이디어

* 연속된 구간에서만 오르막길을 인정한다. (부분수열 X, **연속 부분** O)
* 배열을 왼쪽부터 훑으면서:
  1. **증가(> 직전값)**: 현재 오르막이 이어짐 → `(현재값 − 시작값)`을 계산해 최대값 갱신.
  2. **하락(≤ 직전값)**: 오르막길이 끊김 → 시작점을 현재 위치로 리셋.
* 끝까지 진행 후, 최댓값을 출력. 오르막이 없으면 0.

---

## 예시

* 입력:  
```

5
1 2 1 4 6

```
진행:
- `1→2` 오름 → 크기=1  
- `2→1` 하락 → 끊김, 시작=1  
- `1→4→6` 연속 오름 → 크기=5  
최댓값 = **5**

* 입력:  
```

8
12 20 1 3 4 4 11 1

```
진행:
- `12→20` → 크기=8  
- `1→3→4` → 크기=3  
- `4→11` (앞에서 끊기고 다시 시작) → 크기=7  
최댓값 = **8**

---

## 시행착오

* **부분수열 착각**: 연속 구간만 허용인데, 건너뛰어 이어 붙이면 안 됨.  
* **같은 값(=) 처리 누락**: `3 3 4` 같은 경우 오르막길이 끊겨야 함.  
* **최대값 리셋 실수**: 끊겼다고 `M=0`으로 초기화하면 이전 최대를 날려버림. 최대는 증가할 때만 갱신.  
* **시작점 인덱스 혼동**: 끊기면 `i`가 아니라 `i+1`부터 새로 시작해야 함.  
* **끝 처리 누락**: 마지막 값에서 오르막이 끝날 수도 있으므로, 증가할 때마다 즉시 갱신하는 구조로 해결.

---

## 코드

```java
import java.io.*;
import java.util.*;

public class Main {
  public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      int N = Integer.parseInt(br.readLine());
      StringTokenizer st = new StringTokenizer(br.readLine());
      int[] arr = new int[N];
      for (int i = 0; i < N; i++) arr[i] = Integer.parseInt(st.nextToken());

      int start = 0, max = 0;
      for (int i = 0; i < N - 1; i++) {
          if (arr[i + 1] > arr[i]) {
              max = Math.max(max, arr[i + 1] - arr[start]);
          } else {
              start = i + 1;
          }
      }
      System.out.println(max);
  }
}
```

---

## 정리

핵심은 **연속 증가 구간 추적**:

* 증가가 이어지면 `(현재 − 시작)`으로 최대값 갱신.
* 하락·같음이면 `start`를 새로 잡음.


